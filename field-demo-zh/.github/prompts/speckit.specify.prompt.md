---
description: 从自然语言功能描述创建或更新功能规格说明。
---

## 用户输入

```text
$ARGUMENTS
```

在继续之前，你**必须**考虑用户输入（如果不为空）。

## 概述

用户在触发消息中在 `/speckit.specify` 之后键入的文本**就是**功能描述。假设即使下面字面上显示 `$ARGUMENTS`，你在这个对话中也始终可以使用它。除非用户提供了空命令，否则不要要求用户重复它。

给定该功能描述，请执行以下操作：

1. **生成一个简洁的短名称**（2-4个单词）用于分支：
   - 分析功能描述并提取最有意义的关键词
   - 创建一个2-4个单词的短名称，抓住功能的本质
   - 尽可能使用动名词格式（例如 "add-user-auth"、"fix-payment-bug"）
   - 保留技术术语和缩写（OAuth2、API、JWT 等）
   - 保持简洁但描述性足够，以便一目了然地理解功能
   - 示例：
     - "I want to add user authentication" → "user-auth"
     - "Implement OAuth2 integration for the API" → "oauth2-api-integration"
     - "Create a dashboard for analytics" → "analytics-dashboard"
     - "Fix payment processing timeout bug" → "fix-payment-timeout"

2. 从仓库根目录运行脚本 `.specify/scripts/powershell/create-new-feature.ps1 -Json "$ARGUMENTS"`，并**附带短名称参数**，解析其JSON输出以获取 BRANCH_NAME 和 SPEC_FILE。所有文件路径必须是绝对路径。

   **重要**：

   - 将第1步中创建的2-4个单词的短名称作为参数附加到 `.specify/scripts/powershell/create-new-feature.ps1 -Json "$ARGUMENTS"` 命令
   - Bash: `--short-name "your-generated-short-name"`
   - PowerShell: `-ShortName "your-generated-short-name"`
   - 对于参数中的单引号，如 "I'm Groot"，使用转义语法：例如 'I'\''m Groot'（或尽可能使用双引号："I'm Groot"）
   - 你只能运行此脚本一次
   - JSON 作为输出在终端中提供 - 始终引用它来获取你要查找的实际内容

3. 加载 `.specify/templates/spec-template.md` 以了解所需的部分。

4. 遵循以下执行流程：

    1. 从输入中解析用户描述
       如果为空：ERROR "No feature description provided"
    2. 从描述中提取关键概念
       识别：参与者、动作、数据、约束
    3. 对于不清楚的方面：
       - 根据上下文和行业标准做出明智的猜测
       - 仅在以下情况下标记为 [NEEDS CLARIFICATION: specific question]：
         - 选择显著影响功能范围或用户体验
         - 存在多种具有不同含义的合理解释
         - 不存在合理的默认值
       - **限制：最多3个 [NEEDS CLARIFICATION] 标记**
       - 按影响优先级排序澄清：范围 > 安全/隐私 > 用户体验 > 技术细节
    4. 填写用户场景和测试部分
       如果没有明确的用户流程：ERROR "Cannot determine user scenarios"
    5. 生成功能需求
       每个需求必须是可测试的
       对未指定的细节使用合理的默认值（在假设部分记录假设）
    6. 定义成功标准
       创建可衡量的、与技术无关的结果
       包括定量指标（时间、性能、数量）和定性措施（用户满意度、任务完成情况）
       每个标准必须在没有实现细节的情况下可验证
    7. 识别关键实体（如果涉及数据）
    8. 返回：SUCCESS（规格准备好进行规划）

5. 使用模板结构将规格说明写入 SPEC_FILE，用从功能描述（参数）派生的具体细节替换占位符，同时保留部分顺序和标题。

6. **规格质量验证**：编写初始规格后，根据质量标准验证它：

   a. **创建规格质量检查清单**：使用检查清单模板结构在 `FEATURE_DIR/checklists/requirements.md` 生成检查清单文件，包含以下验证项目：
   
      ```markdown
      # 规格质量检查清单：[FEATURE NAME]
      
      **目的**：在进行规划前验证规格的完整性和质量
      **创建日期**：[DATE]
      **功能**：[链接到 spec.md]
      
      ## 内容质量
      
      - [ ] 没有实现细节（语言、框架、API）
      - [ ] 专注于用户价值和业务需求
      - [ ] 为非技术利益相关者编写
      - [ ] 所有必填部分已完成
      
      ## 需求完整性
      
      - [ ] 没有 [NEEDS CLARIFICATION] 标记
      - [ ] 需求是可测试和明确的
      - [ ] 成功标准是可衡量的
      - [ ] 成功标准与技术无关（没有实现细节）
      - [ ] 所有验收场景都已定义
      - [ ] 已识别边缘情况
      - [ ] 范围明确界定
      - [ ] 已识别依赖项和假设
      
      ## 功能就绪度
      
      - [ ] 所有功能需求都有明确的验收标准
      - [ ] 用户场景涵盖主要流程
      - [ ] 功能满足成功标准中定义的可衡量结果
      - [ ] 没有实现细节泄露到规格中
      
      ## 注释
      
      - 标记为未完成的项目需要在使用 `/speckit.clarify` 或 `/speckit.plan` 前更新规格
      ```
   
   b. **运行验证检查**：根据每个检查清单项目审查规格：
      - 对于每个项目，确定其通过或失败
      - 记录发现的具体问题（引用相关规格部分）
   
   c. **处理验证结果**：
      
      - **如果所有项目通过**：标记检查清单完成并继续执行步骤6
      
      - **如果项目失败（不包括 [NEEDS CLARIFICATION]）**：
        1. 列出失败的项目和具体问题
        2. 更新规格以解决每个问题
        3. 重新运行验证，直到所有项目通过（最多3次迭代）
        4. 如果经过3次迭代后仍然失败，在检查清单注释中记录剩余问题并警告用户
      
      - **如果仍有 [NEEDS CLARIFICATION] 标记**：
        1. 从规格中提取所有 [NEEDS CLARIFICATION: ...] 标记
        2. **限制检查**：如果存在超过3个标记，只保留3个最关键的（按范围/安全/UX影响），其余的做出明智的猜测
        3. 对于每个需要澄清的问题（最多3个），以这种格式向用户提供选项：
        
           ```markdown
           ## 问题 [N]：[主题]
           
           **上下文**：[引用相关规格部分]
           
           **我们需要知道的是**：[NEEDS CLARIFICATION 标记中的具体问题]
           
           **建议答案**：
           
           | 选项 | 答案 | 影响 |
           |--------|--------|--------------|
           | A      | [第一个建议答案] | [这对功能意味着什么] |
           | B      | [第二个建议答案] | [这对功能意味着什么] |
           | C      | [第三个建议答案] | [这对功能意味着什么] |
           | 自定义 | 提供你自己的答案 | [解释如何提供自定义输入] |
           
           **你的选择**：_[等待用户回应]_
           ```
        
        4. **关键 - 表格格式**：确保markdown表格格式正确：
           - 使用一致的空格，管道对齐
           - 每个单元格内容周围应有空格：`| Content |` 而不是 `|Content|`
           - 标题分隔符必须至少有3个破折号：`|--------|`
           - 测试表格在markdown预览中是否正确渲染
        5. 问题按顺序编号（Q1、Q2、Q3 - 最多总共3个）
        6. 在等待响应前一起呈现所有问题
        7. 等待用户响应他们对所有问题的选择（例如 "Q1: A, Q2: Custom - [details], Q3: B"）
        8. 通过用用户选择或提供的答案替换每个 [NEEDS CLARIFICATION] 标记来更新规格
        9. 解决所有澄清后重新运行验证
   
   d. **更新检查清单**：每次验证迭代后，用当前通过/失败状态更新检查清单文件

7. 报告完成情况，包括分支名称、规格文件路径、检查清单结果以及下一阶段（`/speckit.clarify` 或 `/speckit.plan`）的就绪状态。

**注意**：脚本在写入前创建并检出新分支并初始化规格文件。

## 一般指南

## 快速指南

- 专注于用户**需要什么**以及**为什么需要**。
- 避免如何实现（没有技术栈、API、代码结构）。
- 为业务利益相关者编写，而不是开发人员。
- 不要在规格中创建任何嵌入式检查清单。这将是一个单独的命令。

### 部分要求

- **必填部分**：必须为每个功能完成
- **可选部分**：仅在与功能相关时包含
- 当某个部分不适用时，将其完全删除（不要留空为 "N/A"）

### 对于AI生成

从用户提示创建此规格时：

1. **做出明智的猜测**：使用上下文、行业标准和常见模式来填补空白
2. **记录假设**：在假设部分记录合理的默认值
3. **限制澄清**：最多3个 [NEEDS CLARIFICATION] 标记 - 仅用于关键决策：
   - 显著影响功能范围或用户体验
   - 存在多种具有不同含义的合理解释
   - 缺乏任何合理的默认值
4. **优先处理澄清**：范围 > 安全/隐私 > 用户体验 > 技术细节
5. **像测试人员一样思考**：每个模糊的需求都应该在"可测试和明确"检查清单项目中失败
6. **需要澄清的常见领域**（仅在没有合理默认值时）：
   - 功能范围和边界（包括/排除特定用例）
   - 用户类型和权限（如果可能有多种冲突解释）
   - 安全/合规要求（当在法律/财务上很重要时）
   
**合理默认值的例子**（不要询问这些）：

- 数据保留：领域的行业标准实践
- 性能目标：除非指定，否则为标准Web/移动应用期望
- 错误处理：用户友好的消息和适当的回退
- 认证方法：Web应用的标准基于会话或OAuth2
- 集成模式：除非另有说明，否则为RESTful API

### 成功标准指南

成功标准必须：

1. **可衡量**：包括特定指标（时间、百分比、计数、速率）
2. **与技术无关**：不提及框架、语言、数据库或工具
3. **以用户为中心**：从用户/业务角度描述结果，而不是系统内部
4. **可验证**：可以在不知道实现细节的情况下进行测试/验证

**好例子**：

- "用户可以在3分钟内完成结账"
- "系统支持10,000个并发用户"
- "95%的搜索在1秒内返回结果"
- "任务完成率提高40%"

**坏例子**（以实现为中心）：

- "API响应时间低于200ms"（过于技术化，使用"用户立即看到结果"）
- "数据库可以处理1000 TPS"（实现细节，使用面向用户的指标）
- "React组件高效渲染"（特定于框架）
- "Redis缓存命中率高于80%"（特定于技术）