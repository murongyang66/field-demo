---
description: 在任务生成后对spec.md、plan.md和tasks.md进行非破坏性的跨工件一致性和质量分析。
---

## 用户输入

```text
$ARGUMENTS
```

在继续之前，你**必须**考虑用户输入（如果不为空）。

## 目标

在实施前识别三个核心工件（`spec.md`、`plan.md`、`tasks.md`）之间的不一致、重复、歧义以及规格不足的项目。此命令必须仅在`/tasks`成功生成完整的`tasks.md`后运行。

## 操作约束

**严格只读**：**不要**修改任何文件。输出结构化分析报告。提供可选的修复计划（用户必须在手动调用任何后续编辑命令之前明确批准）。

**章程权威性**：项目章程（`.specify/memory/constitution.md`）在此分析范围内是**不可协商的**。章程冲突自动被视为严重级别，需要调整规范、计划或任务，而不是淡化、重新解释或无声地忽略原则。如果原则本身需要更改，必须在`/analyze`之外的单独、明确的章程更新中进行。

## 执行步骤

### 1. 初始化分析上下文

从仓库根目录运行一次`.specify/scripts/powershell/check-prerequisites.ps1 -Json -RequireTasks -IncludeTasks`并解析JSON以获取FEATURE_DIR和AVAILABLE_DOCS。派生绝对路径：

- SPEC = FEATURE_DIR/spec.md
- PLAN = FEATURE_DIR/plan.md
- TASKS = FEATURE_DIR/tasks.md

如果缺少任何必需文件，则中止并显示错误消息（指导用户运行缺失的前提条件命令）。
对于参数中的单引号，如"I'm Groot"，使用转义语法：例如'I'\''m Groot'（或尽可能使用双引号："I'm Groot"）。

### 2. 加载工件（渐进式披露）

仅从每个工件加载必要的最小上下文：

**从spec.md加载**：

- 概述/上下文
- 功能需求
- 非功能需求
- 用户故事
- 边缘情况（如果存在）

**从plan.md加载**：

- 架构/技术栈选择
- 数据模型引用
- 阶段
- 技术约束

**从tasks.md加载**：

- 任务ID
- 描述
- 阶段分组
- 并行标记[P]
- 引用的文件路径

**从章程加载**：

- 加载`.specify/memory/constitution.md`以进行原则验证

### 3. 构建语义模型

创建内部表示（不要在输出中包含原始工件）：

- **需求清单**：每个功能和非功能需求，带有稳定键（基于祈使短语派生slug；例如，"User can upload file"→`user-can-upload-file`）
- **用户故事/动作清单**：具有验收标准的离散用户动作
- **任务覆盖映射**：将每个任务映射到一个或多个需求或故事（通过关键词/显式引用模式如ID或关键短语进行推断）
- **章程规则集**：提取原则名称和MUST/SHOULD规范性陈述

### 4. 检测过程（令牌高效分析）

专注于高信号发现。最多限制50个发现；将其余部分汇总在溢出摘要中。

#### A. 重复检测

- 识别近似重复的需求
- 标记质量较低的表述以便合并

#### B. 歧义检测

- 标记缺乏可测量标准的模糊形容词（快速、可扩展、安全、直观、健壮）
- 标记未解决的占位符（TODO、TKTK、???、`<placeholder>`等）

#### C. 规格不足

- 有动词但缺少对象或可测量结果的需求
- 缺少验收标准对齐的用户故事
- 引用规范/计划中未定义的文件或组件的任务

#### D. 章程对齐

- 任何与MUST原则冲突的需求或计划元素
- 缺少章程中规定的部分或质量关卡

#### E. 覆盖缺口

- 没有相关任务的需求
- 没有映射到需求/故事的任务
- 未反映在任务中的非功能需求（例如性能、安全性）

#### F. 不一致

- 术语漂移（在不同文件中对同一概念命名不同）
- 计划中引用但规范中缺失的数据实体（反之亦然）
- 任务排序矛盾（例如，集成任务在基础设置任务之前，且没有依赖注释）
- 冲突的需求（例如，一个需要Next.js而另一个指定Vue）

### 5. 严重性分配

使用以下启发式方法对发现进行优先级排序：

- **严重**：违反章程MUST、缺少核心规范工件、或阻碍基线功能的零覆盖需求
- **高**：重复或冲突的需求、模糊的安全/性能属性、不可测试的验收标准
- **中**：术语漂移、缺少非功能任务覆盖、规格不足的边缘情况
- **低**：风格/措辞改进、不影响执行顺序的轻微冗余

### 6. 生成简洁分析报告

输出Markdown报告（不写入文件），具有以下结构：

## 规范分析报告

| ID | 类别 | 严重性 | 位置 | 摘要 | 建议 |
|----|----------|----------|-------------|---------|----------------|
| A1 | 重复 | 高 | spec.md:L120-134 | 两个相似的需求... | 合并表述；保留更清晰的版本 |

（每个发现添加一行；生成以类别首字母为前缀的稳定ID。）

**覆盖摘要表**：

| 需求键 | 有任务？ | 任务ID | 备注 |
|-----------------|-----------|----------|-------|

**章程对齐问题**：（如果有）

**未映射任务**：（如果有）

**指标**：

- 需求总数
- 任务总数
- 覆盖率%（有≥1个任务的需求）
- 歧义计数
- 重复计数
- 严重问题计数

### 7. 提供后续操作

在报告末尾，输出简洁的后续操作块：

- 如果存在严重问题：建议在`/implement`前解决
- 如果只有低/中问题：用户可以继续，但提供改进建议
- 提供明确的命令建议：例如，"运行/specify进行细化"，"运行/plan调整架构"，"手动编辑tasks.md添加'performance-metrics'的覆盖"  

### 8. 提供修复方案

询问用户："你想让我为前N个问题提供具体的修复编辑建议吗？"（不要自动应用它们。）

## 操作原则

### 上下文效率

- **最小高信号令牌**：专注于可操作的发现，而非详尽的文档
- **渐进式披露**：增量加载工件；不要将所有内容都转储到分析中
- **令牌高效输出**：限制发现表为50行；汇总溢出部分
- **确定性结果**：在没有更改的情况下重新运行应产生一致的ID和计数

### 分析指南

- **绝不修改文件**（这是只读分析）
- **绝不臆测缺失部分**（如果不存在，准确报告它们）
- **优先处理章程违规**（这些始终是严重的）
- **使用示例而非详尽规则**（引用特定实例，而非通用模式）
- **优雅地报告零问题**（发出成功报告，包含覆盖统计信息）

## 上下文

$ARGUMENTS